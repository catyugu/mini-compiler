// In src/Parser.h

#pragma once

#include "Token.h"
#include "AST.h" // We need the AST node definitions
#include <vector>
#include <memory>
#include <iostream>
#include <string>
#include <unordered_set>

class Parser {
public:
    // The constructor takes the list of tokens generated by the Lexer.
    explicit Parser(const std::vector<Token>& tokens);

    // This is the main entry point for the parser.
    // It will parse the entire sequence of tokens and return a list of statements,
    // which represents the complete program's AST.
    std::vector<std::unique_ptr<StatementNode>> parse();
    const std::unordered_set<std::string> known_type_names = {"int", "float"};

private:
    // --- State ---
    const std::vector<Token>& m_tokens; // The token stream we're parsing
    size_t m_current = 0;               // A cursor pointing to the next token to be consumed

    // --- Grammar Rule Methods ---
    // Each of these methods corresponds to a rule in our language's grammar.
    // They are the core of our recursive descent parser.
    std::unique_ptr<StatementNode> parseStatement();
    std::unique_ptr<StatementNode> parseLetStatement();
    std::unique_ptr<StatementNode> parseExpressionStatement();
    std::vector<std::unique_ptr<ExpressionNode>> parseArguments();
    std::unique_ptr<ExpressionNode> parseCall(); // <-- ADD
    std::unique_ptr<ExpressionNode> parseExpression();
    std::unique_ptr<ExpressionNode> parseAddition();
    std::unique_ptr<ExpressionNode> parseMultiplication();
    std::unique_ptr<ExpressionNode> parsePrimary();

    // --- Utility/Helper Methods ---
    // These are small tools that the grammar methods use to navigate
    // the token stream and handle errors.

    // Checks if we've consumed all tokens.
    bool isAtEnd() const;

    // Returns the current token without consuming it.
    const Token& peek() const;

    // Returns the most recently consumed token.
    const Token& previous() const;

    // Consumes and returns the current token, advancing the cursor.
    Token advance();

    // Checks if the current token is of a specific type.
    bool check(TokenType type) const;

    // Checks if the current token is one of several types.
    // If it is, it consumes the token and returns true. Otherwise, returns false.
    bool match(const std::vector<TokenType>& types);

    // Consumes the current token, but throws an error if it's not the expected type.
    // This is used for mandatory parts of the grammar (like a closing ';').
    Token consume(TokenType type, const std::string& message);
};